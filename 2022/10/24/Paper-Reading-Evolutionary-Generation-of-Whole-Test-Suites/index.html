<!DOCTYPE html><html lang="en" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Jifeng Wu"><meta name="keywords" content=""><meta name="description" content="NOTE: This is a Paper Reading for Topics in Programming Languages: Automated Testing, Bug Detection, and Program Analysis. The original paper can be found here. Background Automatically deriving test"><meta property="og:type" content="article"><meta property="og:title" content="Paper Reading: Evolutionary Generation of Whole Test Suites"><meta property="og:url" content="https://jifengwu2k.github.io/2022/10/24/Paper-Reading-Evolutionary-Generation-of-Whole-Test-Suites/index.html"><meta property="og:site_name" content="Jifeng Wu&#39;s Personal Website"><meta property="og:description" content="NOTE: This is a Paper Reading for Topics in Programming Languages: Automated Testing, Bug Detection, and Program Analysis. The original paper can be found here. Background Automatically deriving test"><meta property="og:locale" content="en_US"><meta property="article:published_time" content="2022-10-24T04:00:00.000Z"><meta property="article:modified_time" content="2025-10-06T02:11:11.869Z"><meta property="article:author" content="Jifeng Wu"><meta name="twitter:card" content="summary_large_image"><title>Paper Reading: Evolutionary Generation of Whole Test Suites - Jifeng Wu&#39;s Personal Website</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"jifengwu2k.github.io",root:"/",version:"1.9.3",typing:{enable:!1,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Jifeng Wu's Personal Website" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Jifeng Wu</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> Home</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> Categories</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> Archives</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">Paper Reading: Evolutionary Generation of Whole Test Suites</span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Jifeng Wu </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-10-24 00:00" pubdate>October 24, 2022</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 11k words </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 90 mins</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Paper Reading: Evolutionary Generation of Whole Test Suites</h1><div class="markdown-body"><p>NOTE: This is a Paper Reading for <a target="_blank" rel="noopener" href="https://www.carolemieux.com/teaching/CPSC539L_2022w1.html">Topics in Programming Languages: Automated Testing, Bug Detection, and Program Analysis</a>. The original paper can be found <a target="_blank" rel="noopener" href="https://doi.org/10.1109/QSIC.2011.19">here</a>.</p><h1 id="background">Background</h1><p>Automatically deriving test cases for realistically sized programs:</p><ul><li>Select one coverage goal (e.g., program branch) at a time, and derive a test case that exercises this particular goal.<ul><li>Solving path constraints generated with symbolic execution / dynamic symbolic execution</li><li>Meta-heuristic search techniques</li><li>Mutation testing</li></ul></li><li>Alternative approaches not directly aimed to achieve code coverage<ul><li>Randoop<ul><li>incrementally generate sequences of function calls to find buggy test sequences</li><li>requires automated oracles (e.g. developer-written assertions and exceptions)</li></ul></li></ul></li></ul><hr><h1 id="problems">Problems</h1><p>Many coverage goals are unreachable.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (size &gt;= values.length) &#123;<br>        resize();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (size &lt; values.length) &#123;<br>        values[size++] = x;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// UNREACHABLE</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="problems-1">Problems</h1><p>Some coverage goals are more difficult to satisfy than others.</p><p>The order of coverage goals is important: a lucky choice can result in a good test suite, while an unlucky choice can result in a waste of resources.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (size &gt;= values.length) &#123;<br>        <span class="hljs-comment">// HARD</span><br>        resize();<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// EASY</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (size &lt; values.length) &#123;<br>        values[size++] = x;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="problems-2">Problems</h1><p>Satisfying a particular coverage goal frequently entails satisfying further coverage goals by accident.</p><p>The order of coverage goals is important.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// May imply coverage in `push` and `resize`</span><br>        <span class="hljs-keyword">return</span> values[size];<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptyStackException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="our-solution-evosuite">Our Solution: EvoSuite</h1><ul><li>Optimize an entire test suite at once instead of considering distinct test cases.</li><li>Evolve a population of test suites towards satisfying a coverage criterion.</li><li>Assume automated oracles are not available, and require the outputs of the test cases to be manually verified.<ul><li>The generated test suites should be of manageable size.</li></ul></li></ul><p>Solves the problem of:</p><ul><li>difficult and unreachable coverage goals</li><li>order of coverage goals</li><li>accidentally satisfying further coverage goals</li></ul><hr><h1 id="our-solution-evosuite-1">Our Solution: EvoSuite</h1><p>Questions:</p><ul><li>We are interested in sequences in OOP. Should coverage in terms of a new ordering seen in the last <span class="math inline">\(n\)</span> function calls in the sequence should make more sense? (Praveen)</li><li>It seems like Evosuite offloads the responsibility of adding in correct assertions to the developers. How easy is it for the developers to do this, especially when compared with manually writing all of the test suite? (Shizuko, ToTo, Larry)</li></ul><hr><h1 id="evosuite-modeling">EvoSuite Modeling</h1><p>Population 1 .. M Test Suite 1 .. N Test Case 1 .. L Statement</p><p>Four types of statements are modeled.</p><ul><li>Primitive statements: numeric variables (e.g. <code>int var0 = 54;</code>)</li><li>Constructor statements: new instances of a class (e.g. <code>Stack var1 = new Stack();</code>). All parameters of the constructor call have to be values of previous statements.</li><li>Field statements: public fields of objects (e.g. <code>int var2 = var1.size;</code>). If the field is non-static, then the source object of the field has to be a value of a previous statement.</li><li>Method statements: public methods of objects (e.g. <code>int var3 = var1.pop();</code>). The source object and all parameters have to be values of previous statements.</li></ul><hr><h1 id="evosuite-modeling-1">EvoSuite Modeling</h1><p>The set of available classes, their public constructors, methods, and fields are extracted from the given software under test.</p><p>An optimal solution is a test suite that covers all the feasible branches/methods and is minimal in the number of statements.</p><hr><h1 id="evosuite-process-overview">EvoSuite Process Overview</h1><ul><li>Randomly generate a set of initial test suites.</li><li>Evolve using evolutionary search towards satisfying a coverage criterion.</li><li>Minimize the best resulting test suite.</li></ul><p>Questions:</p><ul><li>How are test suites randomly generated? The author discusses "sampling". Where are we sampling from? (Larry, Jifeng)</li></ul><hr><h1 id="evolutionary-search">Evolutionary Search</h1><ul><li>Test Suite Fitness Function</li><li>Crossover</li><li>Accepting the Mutated Offspring</li><li>Bloat Control</li></ul><hr><h1 id="test-suite-fitness-function">Test Suite Fitness Function</h1><p>Covering all branches <span class="math inline">\(B\)</span> and methods <span class="math inline">\(M\)</span> of a program.</p><ul><li>To estimates how close a test suite <span class="math inline">\(T\)</span> is to covering all branches <span class="math inline">\(B\)</span> of a program, for each branch <span class="math inline">\(b\)</span>, <strong>minimal branch distance</strong> <span class="math inline">\(d_{min}(b, T)\)</span> is measured. If the branch predicate is <span class="math inline">\(x \ge 10\)</span>, and during execution, <span class="math inline">\(x == 5\)</span>, then the minimal branch distance is <span class="math inline">\(10 - 5 = 5\)</span>.</li><li>The minimal branch distance is then normalized to get the <strong>branch distance</strong> <span class="math inline">\(d(b, T) = f(d_{min}(b, T))\)</span>, where <span class="math inline">\(f(x) = \frac{x}{x + 1}\)</span>.</li></ul><p><span class="math inline">\(fitness(T) = |M| - |M_T| + \sum_{b \in B}{d(b, T)}\)</span></p><p>If execution exceeds a time limit of 5 minutes, maximum fitness is automatically assigned.</p><hr><h1 id="test-suite-fitness-function-1">Test Suite Fitness Function</h1><p>Questions:</p><ul><li>What does branch distance actually mean? Why do we use it? (Eric, Rut, Yayu, Udit, Jifeng)</li><li>Doesn't <span class="math inline">\(\sum_{b \in B}{d(b, T)}\)</span> already consider that branch distances are maximal in unvisited methods? Why do we need an additional <span class="math inline">\(|M| - |M_T|\)</span> term? Furthermore, different methods could have a different number of branches. Should the branch distance sum for all branches within a method be normalized? (Jifeng)</li></ul><hr><h1 id="crossover">Crossover</h1><p>Rank selection based on the fitness function is used to select two parent test suites <span class="math inline">\(P_1\)</span> and <span class="math inline">\(P_2\)</span> for crossover. In case of ties, smaller test suites are assigned better ranks.</p><p>During crossover:</p><ul><li>a random value <span class="math inline">\(\alpha\)</span> is chosen from <span class="math inline">\((0, 1)\)</span></li><li>the first offspring test suite <span class="math inline">\(O_1\)</span> will contain the first <span class="math inline">\(\alpha |P_1|\)</span> test cases from <span class="math inline">\(P_1\)</span> and the last <span class="math inline">\((1 - \alpha)|P_2|\)</span> test cases from <span class="math inline">\(P_2\)</span></li><li>the second offspring test suite <span class="math inline">\(O_2\)</span> will contain the first <span class="math inline">\(\alpha |P_2|\)</span> test cases from <span class="math inline">\(P_2\)</span> and the last <span class="math inline">\((1 - \alpha)|P_1|\)</span> test cases from <span class="math inline">\(P_1\)</span></li><li>because test cases are independent, <span class="math inline">\(O_1\)</span> and <span class="math inline">\(O_2\)</span> will always be valid</li></ul><hr><h1 id="mutation">Mutation</h1><p>The two offspring test suites <span class="math inline">\(O_1\)</span> and <span class="math inline">\(O_2\)</span> are then mutated.</p><p>When a test suite T is mutated, each of its <strong>test cases</strong> is mutated with probability <span class="math inline">\(\frac{1}{|T|}\)</span>.</p><p>If a test case <span class="math inline">\(t\)</span> is mutated, <strong>remove statements</strong>, <strong>change statements</strong>, and <strong>insert statements</strong> are each applied with probability <span class="math inline">\(\frac{1}{3}\)</span>. Then, a number of new random test cases are added to <span class="math inline">\(T\)</span>.</p><hr><h1 id="remove-statements">Remove Statements</h1><ul><li>If a test case <span class="math inline">\(t\)</span> contains <span class="math inline">\(n\)</span> statements, each statement is removed with probability <span class="math inline">\(\frac{1}{n}\)</span>.</li><li>If the removed statement <span class="math inline">\(s_i\)</span> is subsequently used by <span class="math inline">\(s_j (j &gt; i)\)</span>, try to replace this use with another statement before <span class="math inline">\(s_j\)</span>.<ul><li>If this is not possible, recursively remove <span class="math inline">\(s_j\)</span>.</li></ul></li><li>If all statements have been removed from <span class="math inline">\(t\)</span>, remove <span class="math inline">\(t\)</span> from <span class="math inline">\(T\)</span>.</li></ul><hr><h1 id="change-statements">Change Statements</h1><ul><li>If a test case <span class="math inline">\(t\)</span> contains <span class="math inline">\(n\)</span> statements, each statement is changed with probability <span class="math inline">\(\frac{1}{n}\)</span>.</li><li>If the changed statement <span class="math inline">\(s_i\)</span> is a primitive statement, its numeric value is changed by a random value.</li><li>Otherwise, a method, field, or constructor with the same return type is randomly chosen.</li></ul><hr><h1 id="insert-statements">Insert Statements</h1><ul><li>With probability <span class="math inline">\(p\)</span>, a new statement is inserted at a random position in the test case.</li><li>With probability <span class="math inline">\(p^2\)</span>, a second statement is inserted, and so on.</li></ul><hr><p>Questions:</p><ul><li>What are the justifications for the probabilities? (Kevin)</li><li>Can we change the probabilities used in the mutation and insertion by using method calls they kept track of and variables generated in each iteration? (Joyce)</li><li>When deleting, if the statement is chosen from the beginning few statements, is there a high probability that many/multiple following statements would be removed? Because an initial statement usually has a higher probability of containing an initialization/declaration function. (Rut)</li><li>Why is the probability of inserting the first, second, etc. statement different? This is not the case with remove statements and change statements. (Jifeng)</li><li>To mutate and generate test cases, the GA algorithm should have knowledge of the programming language constructs, fields &amp; methods of the software under test, etc. Does this require a significant engineering effort? (Udit)</li></ul><hr><h1 id="accepting-the-mutated-offspring">Accepting the Mutated Offspring</h1><p>The coverage achieved by the Mutated Offspring is measured by the Test Suite Fitness Function.</p><p>Conditions for accepting the mutated offspring:</p><ul><li>The coverage achieved by the Mutated Offspring <strong>exceeds that achieved by its parents</strong>, or is on par with that achieved by its parents, <strong>and that the mutated offspring are shorter</strong>.</li><li>Their length do not exceed <strong>twice</strong> that of the Test Suite with the best coverage in the community.</li></ul><hr><h1 id="accepting-the-mutated-offspring-1">Accepting the Mutated Offspring</h1><p>Questions:</p><ul><li>Are the parents removed before adding the children? (Rut)</li><li>Compared with the single branch strategy, only the crossover is different, and the mutation is done in the same way. (Tarcisio)</li></ul><hr><h1 id="bloat-control">Bloat Control</h1><p>A <strong>variable size representation</strong> could lead to bloat, where <strong>small negligible improvements in the fitness value are obtained with larger solutions.</strong></p><p>This is a <strong>very common problem in Genetic Programming</strong>.</p><p>The following measures are used for bloat control:</p><ul><li>Limit the maximum number <span class="math inline">\(N\)</span> of test cases within a test suite and the maximum number of statements <span class="math inline">\(L\)</span> within a test case. (still need to choose comparatively larger <span class="math inline">\(N\)</span> and <span class="math inline">\(L\)</span> and then reduce their length during/after the search to dramatically boost coverage)</li><li>Crossover selection policy</li><li>Mutated offspring acception policy</li></ul><hr><h1 id="bloat-control-1">Bloat Control</h1><p>Questions:</p><ul><li>Does coverage-guided fuzzing, which uses a variant of Genetic Programming, suffer from bloat? If so, could any measures be applied to solve this problem? (Jifeng)</li><li>How to reduce the length during/after the search? (Yayu, Jifeng)</li></ul><hr><h1 id="evaluation">Evaluation</h1><p>EvoSuite is compared with the traditional single branch approach on top of EvoSuite infrastructure.</p><ul><li>Offspring is generated using the crossover function, but is conducted on two sequences of statements.<ul><li>Because there are dependencies between statements, the statements of the second part are appended one at a time, trying to satisfy dependencies with existing values, generating new values if necessary.</li></ul></li><li>The traditional approach level plus normalized branch distance fitness function is used.</li></ul><p>The two approaches are compared on five open source libraries and a subset of an industrial case study project previously used by Arcuri et al. The units are testable without complex interactions with external resources and are not multithreaded.</p><hr><h1 id="evaluation-1">Evaluation</h1><p>"Best practices" based on past experience are used for EvoSuite:</p><ul><li>Population size: 80</li><li>Maximum test suite size <span class="math inline">\(N = 100\)</span></li><li>Maximum test case size <span class="math inline">\(L = 80\)</span></li><li>The initial test suites are generated with 2 test cases each</li><li>Initial probability for test case insertion: 0.1</li><li>Crossover probability: 3 / 4</li><li>Initial probability for statement insertion: 0.5</li></ul><hr><h1 id="evaluation-2">Evaluation</h1><p>The search operators for test cases make use of only the type information in the test cluster, and so difficulties can arise when method signatures are imprecise. To overcome this problem for container classes, we always put Integer objects into container classes, and cast returned Object instances back to Integer.</p><p>As the length of test cases can vary greatly and longer test cases generally have higher coverage, we decided to take the number of executed statements as execution limit. The search is performed until either a solution with 100% branch coverage is found, or <span class="math inline">\(k = 1,000,000\)</span> statements have been executed as part of the fitness evaluations.</p><hr><h1 id="evaluation-3">Evaluation</h1><p>Questions:</p><ul><li>Why not compare EvoSuite to any other (non genetic-testing based) approach? (Zack)</li><li>Why "the units are testable without complex interactions with external resources and are not multithreaded"? (Marie)</li><li>Is there a justification for these "best practices"? (Praveen, Kevin, Madonna, Jifeng)</li><li>Do the "best practices" overfit the 5 open-source libraries? (Joyce)</li><li>Why the choice of an Integer? And does it work in practice? Given that the internals of the program might be expecting something else? (Rut)</li></ul><hr><h1 id="results">Results</h1><ul><li>Whole test suite generation achieves higher coverage than single branch test case generation.</li><li>Whole test suite generation produces smaller test suites than single branch test case generation.</li></ul><hr><h1 id="results-1">Results</h1><p>Questions:</p><ul><li>While we have focused on branch coverage in this paper, the findings also carry over to other test criteria is an unwarranted extrapolation. (Zack)</li><li>Evosuite claims that the test cases are smaller, but how much smaller? (not obvious from Figure 7) (ToTo)</li><li>High coverage test suite does not necessary mean high bug-finding abilities.</li><li>How does the performance compare to other tools? (ToTo, Praveen, Kevin, Madonna)</li><li>The authors did not evaluate EvoSuite against a human in software engineering. Whether EvoSuite will improve the ability to test software from a software developer's point of view is unknown. (Marie)</li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Research-Inspiration/" class="category-chain-item">Research Inspiration</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>Paper Reading: Evolutionary Generation of Whole Test Suites</div><div>https://jifengwu2k.github.io/2022/10/24/Paper-Reading-Evolutionary-Generation-of-Whole-Test-Suites/</div></div><div class="license-meta"><div class="license-meta-item"><div>Author</div><div>Jifeng Wu</div></div><div class="license-meta-item license-meta-date"><div>Posted on</div><div>October 24, 2022</div></div><div class="license-meta-item"><div>Licensed under</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - Attribution"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/10/25/Paper-Reading-ReCrash-Making-Software-Failures-Reproducible-by-Preserving-Object-States/" title="Paper Reading: ReCrash: Making Software Failures Reproducible by Preserving Object States"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Paper Reading: ReCrash: Making Software Failures Reproducible by Preserving Object States</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/2022/10/20/Personal-Website-Design-Considerations/" title="Personal Website Design Considerations"><span class="hidden-mobile">Personal Website Design Considerations</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){var t=document.documentElement.getAttribute("data-user-color-scheme");t="dark"===t?"github-dark":"github-light",window.UtterancesThemeLight="github-light",window.UtterancesThemeDark="github-dark";var e=document.createElement("script");e.setAttribute("src","https://utteranc.es/client.js"),e.setAttribute("repo","abbaswu/utterances"),e.setAttribute("issue-term","pathname"),e.setAttribute("label","utterances"),e.setAttribute("theme",t),e.setAttribute("crossorigin","anonymous"),document.getElementById("comments").appendChild(e)}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">Keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script>window.MathJax?(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise()):window.MathJax={tex:{inlineMath:{"[+]":[["$","$"]]}},loader:{load:["ui/lazy"]},options:{renderActions:{insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{let e=t.parentNode;"li"===e.nodeName.toLowerCase()&&e.parentNode.classList.add("has-jax")})},"",!1]}}},Fluid.events.registerRefreshCallback((function(){"MathJax"in window&&MathJax.startup.document&&"function"==typeof MathJax.startup.document.state&&(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise())}))</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">Blog works best with JavaScript enabled</div></noscript></body></html>